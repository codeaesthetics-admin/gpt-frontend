import { Injectable } from '@nestjs/common';
import axios from 'axios';
const fs = require('fs');

@Injectable()
export class ChatGptAiService {
  private OPENAI_API_KEY = process.env.OPEN_AI_KEY;

  async generateText(latestPrompt: string, prompt: string, fileName: string) {
    try {
      /** 
      * Updated Flow
      * User Question -> Security Bot -> Answer
      * User Question + Bot-1 Answer -> Sales rep bot -> Answer
      * Answer from sales rep bot + user question -> Security Bot -> Final Output
      **/
      //  
      await saveLogsInFile(fileName, `\n[Date/Time: ${new Date()}] \n[User query: ${prompt}]`)
      // Calling security bot that will check the validity of the user query
      let initialResponse = await getQueryReview(prompt, this.OPENAI_API_KEY);
      await saveLogsInFile(fileName, `\n[Date/Time: ${new Date()}] \n[Security Bot Response : ${initialResponse.text}]`)
      if (initialResponse.text === 'NO'
        || initialResponse.text === 'NO.'
        || initialResponse.text.startsWith('No')
        || initialResponse.text.startsWith('NO.')) {
        return { role: "Assistant", text: process.env.UNAUTHORIZED_ENV_REPLY };
      } else {
        // Calling sales bot that will give regular response to the user query
        let middleResponse = await getRepReply(prompt, this.OPENAI_API_KEY);

        // Save Sale rep response in log file
        await saveLogsInFile(fileName, `\n[Date/Time: ${new Date()}] \n[Sales reply : ${middleResponse.text}]`)

        // Calling security bot again that will check the validity of the response generated by the sales rep bot and send final response
        let finalResponse = await getReplyReview(prompt, middleResponse.text, this.OPENAI_API_KEY);

        /** Now if the response returned by the middle channel is safe, we will return that as response, 
        otherwise we will send the response generated by the final channel **/
        if (finalResponse.text === 'UnSafe'
          || finalResponse.text === 'UnSafe.'
          || finalResponse.text.startsWith('UnSafe')
          || finalResponse.text.startsWith('UnSafe.')) {
          finalResponse.text = finalResponse.text.replace('UnSafe.', '');
          finalResponse.text = finalResponse.text.replace('UnSafe.', '');

          // Save in log file
          await saveLogsInFile(fileName, `\n[Date/Time: ${new Date()}] \n[Security Bot reply after reviewing sales rep : ${process.env.UNAUTHORIZED_ENV_REPLY}]`)
          // Retrun the "unauthrized" response 
          return { role: "Assistant", text: process.env.UNAUTHORIZED_ENV_REPLY }
        } else {
          // Save response in log file
          await saveLogsInFile(fileName, `\n[Date/Time: ${new Date()}] \n[Security Bot reply after reviewing sales rep : ${middleResponse.text}]`)
          // Retrun response generated by the middle channel
          return middleResponse
        }
      }
    } catch (err) {
      console.log(err.message);
      await saveLogsInFile(fileName, `\n[Date/Time: ${new Date()}] \n[Security Bot reply after reviewing sales rep : Something went wrong please try again!]`)
      return { role: "System", text: "Something went wrong please try again!" }
    }
  }
}

let getQueryReview = async (userPrompt: string, key: string) => {
  // initial query to be sent to security bot from env
  let envPrompt = process.env.ENV_QUERY_REVIEW
  let updatedPromt = `${envPrompt} Customer's question is: ${userPrompt}. Does this question comply with the ccompany's policy? `

  // Create request data to be passed into the open Ai API request
  let data = await openApiCall(key, updatedPromt);
  return data
}
let getRepReply = async (repMessage: string, key: string) => {
  let envPrompt = process.env.ENV_REP_QUERY
  let updatedPromt = `${envPrompt} Rep's message : ${repMessage} is the Rep's message safe based on the company policy? Answer with 'unsafe' if it isn't `

  // Create request data to be passed into the open Ai API request
  let data = await openApiCall(key, updatedPromt);
  return data
}
let getReplyReview = async (customerMessage: string, middlePrompt: string, key: string) => {
  let envPrompt = process.env.ENV_REPLY_REVIEW
  let updatedPromt = `${envPrompt} 
  ${process.env.SECOND_PRE_PROMPT_ENV_QUERY}
  Customer's message : ${customerMessage}  and sales rep response is: ${middlePrompt} `

  // Create request data to be passed into the open Ai API request
  let data = await openApiCall(key, updatedPromt);
  return data
}

let openApiCall = async (key: string, updatedPromt: string) => {
  const requestData = {
    model: 'gpt-3.5-turbo',
    messages: [{ role: 'system', content: updatedPromt }],
    temperature: 0
  };
  const config = {
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${key}`
    }
  };
  const response = await axios.post('https://api.openai.com/v1/chat/completions', requestData, config);
  const choices = response.data.choices;
  let text = choices[0].message.content.trim();
  let role = choices[0].message.role;
  return { text, role }
}

let saveLogsInFile = async (fileName, content) => {
  let filePath = `./logs/${fileName}.txt`
  if (fs.existsSync(filePath)) {
    // if the file already exists, read its contents
    const contents = fs.readFileSync(filePath, 'utf-8');

    if (contents.length > 0) {
      // if the file is not empty, add a new line before appending new text
      fs.appendFileSync(filePath, '\n' + content);
    } else {
      // if the file is empty, just append the new text without a new line
      fs.appendFileSync(filePath, content);
    }

    console.log('File exists and new text has been appended.');
  } else {
    // if the file does not exist, create a new file with the new text
    fs.writeFileSync(filePath, content);
    console.log('File does not exist and has been created with new text.');
  }
}